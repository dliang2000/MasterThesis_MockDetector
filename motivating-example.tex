%======================================================================
\chapter{Motivation}
\label{chap:motivation}
%====================================================================== 

In this chapter, we run through a real-world example selected from benchmark \texttt{maven}. The unit test case contains both a real object and a mock object, and there is a method invocation on each of them. We then present a simplified toy example with corresponding IR processed and used by static analysis tools. We demonstrate why the current tools are incompetent to differentiate mock objects from real objects. However, before diving into the current project, let us take a step back and talk about what led us to the research on detecting mock objects and tracking mock invocations.

\section{Preliminary Research}
\label{sec:preliminary}

\begin{figure}[h]
	\centering
	\input{withZone.tikz}
	\caption[Caption for SiblingClass untested method.]{joda-time contains superclass \textit{AssembledChronology} and subclasses \textit{BuddhistChronology}, \textit{GJChronology}, \textit{StrictChronology}, and others. Method \textit{withZone()} is tested in \textit{Buddhist-} and \textit{GJChronology} but not \textit{StrictChronology}.\footnotemark}
	\label{fig:hierarchyView}
\end{figure}

\footnotetext{The content of this figure have been incorporated within a NIER paper published by IEEE in 2020 IEEE International Conference on Software Maintenance and Evolution (ICSME), available online: https://ieeexplore.ieee.org/xpl/conhome/9240597/proceeding[doi: 10.1109/ICSME46990.2020.00075]. Qian Liang and Patrick Lam, "SiblingClassTestDetector: Finding Untested Sibling Functions"}

Prior to the development for \textsc{MockDetector}, we were working on a project to detect untested functions that have analogous implementations in sibling classes (they share a common superclass), where at least one of the related implementations are tested. The overall goal of that project is to reduce untested code. Though testing could not guarantee desired program behaviour, developers certainly know nothing about any untested code. Since the sibling methods share the same specification, it is likely that a unit test case covering for one sibling class's implementation may also work for the untested after small modifications, potentially increasing the statement coverage and consequently having a better chance to gain behavioural insight of the benchmark.

Figure~\ref{fig:hierarchyView} illustrates such an example from an open-source benchmark, joda-time (version 2.10.5). The abstract class \textit{AssembledChronology} inherits the specification of method \textit{withZone()} from its parent class, which is not shown in the Figure. \textit{AssembledChronology}'s subclasses \textit{BuddhistChronology}, \textit{GJChronology}, \textit{StrictChronology}, and many others are at the same hierarchy level, which are defined as sibling classes. These sibling classes all have an implementation of \textit{withZone()}; however, the \textit{withZone()} implementations in \textit{BuddhistChronology} and \textit{GJChronology} are tested, whereas the implementation in \textit{StrictChronology} is not.

As the research progressed, we encountered the test case in Listing~\ref{lis:siblingMethodCall}, and realized that it would be a necessary step to remove method invocations on mock objects from the call graph generated by existing static analysis frameworks, as otherwise we may mistakenly treat such test case as the one covering for the tested sibling method, since the existing static analyses tools could not distinguish method invocations on mock objects from method invocations on real objects. 

\begin{lstlisting}[basicstyle=\ttfamily, caption={This code snippet illustrates an example from commons-collections4, where the method \textit{addAll()} invoked on the mock object \texttt{c} could be mislabelled as a focal method.},
basicstyle=\ttfamily,language = Java, framesep=4.5mm, escapechar=|,
framexleftmargin=1.0mm, captionpos=b, label=lis:siblingMethodCall, morekeywords={@Test}]

@Test
public void addAllForIterable() {
final Collection<Integer> inputCollection = createMock(Collection.class);
...
final Collection<Number> c = createMock(Collection.class);
...
expect(c.addAll(inputCollection)).andReturn(false);
}
\end{lstlisting}

\section{Running Example: Detecting Mock Objects and Mock Invocations}
\label{sec:running-example}

To motivate our work, consider Listing~\ref{lis:mockCall}, which presents a unit test case from the Maven project. Line~\ref{line:mock} calls \textit{getRequest()}, invoking it on the mock object \texttt{session}. Line~\ref{line:real} then calls \textit{getToolchainsForType()}, which happens to be the focal method whose behaviour is being tested in this test case. At the bytecode level, the two method invocations are indistinguishable with respect to mockness; to our knowledge, current static analysis tools cannot easily tell the difference between the method invocation on a mock object on line~\ref{line:mock} and the method invocation on a real object on line~\ref{line:real}. Given mockness information, an IDE could provide better suggestions. The uncertainty about mockness would confound a naive static analysis that attempts to identify focal methods. For instance, Ghafari et al's heuristic~\cite{ghafari15:_autom} would fail on this test, as it returns the last mutator method in the object under test, and the focal method here is an accessor.

\begin{lstlisting}[basicstyle=\ttfamily, caption={This code snippet illustrates an example from maven-core, where calls to both the focal method \texttt{getToolchainsForType()} and to mock \texttt{session}'s \texttt{getRequest()} method occur in the test \textit{testMisconfiguredToolchain()}.},
basicstyle=\ttfamily,language = Java, framesep=4.5mm, escapechar=|,
framexleftmargin=1.0mm, captionpos=b, label=lis:mockCall, morekeywords={@Test}]
@Test
public void testMisconfiguredToolchain() throws Exception {
	MavenSession session = mock( MavenSession.class );
	MavenExecutionRequest req = new DefaultMavenExecutionRequest();
	when( session.getRequest() ).thenReturn( req ); |\label{line:mock}|

	ToolchainPrivate[] basics =
			toolchainManager.getToolchainsForType("basic", session); |\label{line:real}|

	assertEquals( 0, basics.length );
}
\end{lstlisting}

\section{A Toy Example}
\label{sec:toy-example}

In this section, we show how hard it is to differentiate mocks from actuals on IR. The toy example serves the same purpose as the one in Listing~\ref{lis:mockCall} but comes with a simpler Jimple IR for easier explanation.

Listing~\ref{lis:mockMethod} shows the creation of two \texttt{java.lang.Object} objects: \texttt{object1} and \texttt{object2}. \texttt{object1} is created via normal initialization by calling to a constructor, thus it is a real object. Meanwhile, \texttt{object2} is created by invoking Mockito's mock API returning a mock object, thus \texttt{object2} is a mock object.

Listing~\ref{lis:mockMethodIR} displays the Jimple IR for Listing~\ref{lis:mockMethod}, where \texttt{\$r1} and \texttt{r2} are the Jimple IRs of \texttt{object1} and \texttt{object2}, respectively. Though the initialization of \texttt{\$r1} and \texttt{r2} are from different types of invocations, since the static analysis tool does not recognize the mock source method from Mockito, the tool views both \texttt{\$r1} and \texttt{r2} as real objects (they are both of type \texttt{java.lang.Object} after all). Therefore, the tool is unable to recognize the invocation of \textit{foo()} on line~\ref{line:lis3line10} is definitely \textit{not} a focal method.

\begin{lstlisting}[basicstyle=\ttfamily, caption={A toy example illustrates a real object \texttt{object1} and a mock object \texttt{object2}, and their corresponding method invocations of \textit{foo()}.},
basicstyle=\ttfamily, captionpos=b, label=lis:mockMethod, escapechar=|, morekeywords={@Test, specialinvoke, virtualinvoke, staticinvoke}]
	Object object1 = new Object();
	object1.foo();
	
	Object object2 = mock(Object.class);
	object2.foo();
\end{lstlisting}



\begin{lstlisting}[basicstyle=\ttfamily, caption={Jimple Intermediate Representation for the code in Listing~\ref{lis:mockMethod}.},
basicstyle=\ttfamily, captionpos=b, label=lis:mockMethodIR, escapechar=|, morekeywords={@Test, specialinvoke, virtualinvoke, staticinvoke}]
	java.lang.Object $r1, r2;
	
	$r1 = new java.lang.Object; |\label{line:lis3line3}|
	specialinvoke $r1.<java.lang.Object: void <init>()>(); |\label{line:lis3line4}|
	virtualinvoke $r1.<java.lang.Object: void foo()>(); |\label{line:lis3line5}|
	
	r2 = staticinvoke <org.mockito.Mockito: |\label{line:lis3line7}|
					java.lang.Object mock(java.lang.Class)> |\label{line:lis3line8}|
					(class "Ljava/lang/Object;");
	virtualinvoke r2.<java.lang.Object: void foo()>(); |\label{line:lis3line10}|
\end{lstlisting}


% I am not sure how to deal with this example of arrays and collections yet. The listing here will be moved to technique section as well, but I am not sure how much content I should still leave here.
%\section{Extensions: arrays and collections} 
%
%While we were designing \textsc{MockDetector}, we observed several cases where developers store mock objects in arrays and collections. Listing~\ref{lis:container} presents method \textit{setUp()} in class \texttt{NodeListIteratorTest} from commons-collections-4.4, where line \ref{line:storeMocksInArray} puts the mock \texttt{Node} objects in the array-typed field \texttt{nodes}. This field is later used in test cases. When the flow function of the dataflow analysis encounters an assignment statement containing an array read or write, it first looks for values (local variables or field reference sources) on the opposite side of the assignment statement---the statement's destination or source, respectively---in the Jimple intermediate representation. It then checks whether any of these local variables or field references have been marked as mock objects in the analysis. If so, the tool marks the local variable or field reference representing the array as an array mock---it propagates the mockness to the array container.
%
%
%\begin{lstlisting}[basicstyle=\ttfamily, caption={This example illustrates a field array container holding mock objects from \textit{setup()} in \texttt{NodeListIteratorTest.java}.},
%basicstyle=\ttfamily,language = Java, framesep=4.5mm, framexleftmargin=1.0mm, captionpos=b, label=lis:container, escapechar=|, morekeywords={@Test}]
%// Node array to be filled with mock Node instances
%private Node[] nodes;
%@Test
%protected void setUp() throws Exception {
%	// create mock Node Instances and 
%	// fill Node[] to be used by test cases
%	final Node node1 = createMock(Element.class);
%	final Node node2 = createMock(Element.class);
%	final Node node3 = createMock(Text.class);
%	final Node node4 = createMock(Element.class);
%	nodes = new Node[] {node1, node2, node3, node4}; |\label{line:storeMocksInArray}|
%	// ...
%}
%\end{lstlisting}
%
%
%The declarative analysis uses analogous reasoning, but uses a relation \\ \texttt{isArrayLocalThatContainsMocks} instead of a bit in the MockStatus abstraction.

