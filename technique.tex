%======================================================================
\chapter{Technique}
\label{chap:technique}	
%======================================================================

We present two complementary ways of statically computing mock information: an imperative implementation of a dataflow analysis (using the Soot program analysis framework), and a declarative implementation (using the Doop framework). We started this project with the usual imperative approach to implementing a static analysis---in our context, that meant using Soot. Then, when we wanted to experiment with adding more features to the analysis, we decided that this was a good opportunity to learn about Doop's declarative approach as well. We added new features to the Doop implementation and backported them to the Soot implementation. While the core analysis is similar, the different implementation technologies have different affordances. For instance, it is easier for the Doop version to mark a field as mock-containing (we added 3 rules) than for the Soot version to do so. We start by describing each implementation in turn, and conclude this section with the commonalities between the two implementations. Chapter~\ref{chap:evaluation} then presents the results obtained using each technology and compares them. 

% Regarding Gregor's comments on affordances, maybe use advantages or other words?

\section{High Level Definition}
\label{sec:high-level}

In this section, we present the high level definitions for mockness. We 

\section{Imperative Soot Implementation}
\label{sec:soot}
We first describe the Soot-based imperative dataflow analysis to find mock invocation sites. Our tool tracks information from the creation sites through the control-flow graph using a forward dataflow may-analysis---an object is declared a mock if there exists some execution path where it may receive a mock value. Our implementation also understands containers like arrays and collections, and tracks whether containers hold any mock objects. The abstraction marks all contents of collections as potential mocks if it observes any mock object being put into the array or container.


\subsection{Forward Dataflow May Analysis}

%To solve the problem, our tool uses forward may analysis, where it analyzes statements from top to bottom, and to keep variables that are verified to be mocks on any possible path at merged points. \textsc{MockDetector} uses the abstraction 
Our forward dataflow analysis maps values (locals and field references) in the Jimple intermediate representation to our abstraction:
\[ \mathtt{Value} \mapsto \mathtt{MockStatus}. \]
\texttt{MockStatus} records three bits: one for the value being a mock, one for it being an array containing a mock, and one for it being a collection containing a mock. At most one of the three bits may be true for any given value. Not having a mapping in the abstraction is equivalent to mapping to a MockStatus having all three bits false. 

We chose to implement a may-analysis rather than a must-analysis for two reasons: 1) we did not observe any cases where a value was assigned a mock on one branch and a real object on the other branch of an if statement; 2) implementing a must-analysis would not help heuristics to find focal methods, as a must-analysis would rule out fewer mock invocations. Our merge operation is therefore a fairly standard pointwise disjunction of the two incoming values in terms of values and in terms of the 3 bits of \texttt{MockStatus}.

%% \textsc{MockDetector} implements the "may" logic in the following manner: it checks the two in-flows 
%% of \begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
%% Map<Value, MockStatus>
%% \end{lstlisting}
%% from two paths. For any variable that is only stored in one map, the key-value pair is directly passed to the out-flow map. For a variable that is a shared key of the two maps, the analysis would update the out-flow's MockStatus by applying the "OR" operation on the "May Mock", "Array Mock", and "Collection Mock" bits from the MockStatus value retrieved from both in-flow maps. 

%% For each statement in a forward flow analysis, we consider two sets: generated set and killed set. In this study, the first set contains the locals that are judged to become mocks, whereas the killed set containing locals that are determined to no longer to be mocks. Equations (1) and (2) illustrates how the inflow and outflow are defined and calculated for each unit: $In(u)$, representing a program point before executing $u$, is the intersection of all outflows after executing each element in immediate predecessor statements of $u$; $Out(u)$, on the other hand, is determined by first removing the killed set from $In(u)$, and union the result with generated set. 

%% \begin{equation}
%% \mathrm{In}(u) = \bigcap_{u' \in preds(u)} \mathrm{Out}(u') 
%% \end{equation}

%% \begin{equation}
%% \mathrm{Out}(u) = (\mathrm{In}(u) - \mathrm{Kill}(u)) \bigcup \mathrm{Gen}(u) 
%% \end{equation}

Our dataflow analysis uses fairly standard gen and kill sets in the flow function. We set bits in \texttt{MockStatus} as follows:

First, the gen set includes pre-analyzed fields containing mock objects defined via annotation (e.g. \texttt{@Mock}), inside a constructor \texttt{<init>}, or in JUnit's \texttt{@Before}/\texttt{setUp()} methods. We discuss the pre-analysis below in Section~\ref{subsec:pre-analysis}. 

Second, it includes local variables assigned from mock-creation source methods, which consist of Mockito's \textit{java.lang.Object mock(java.lang.Class)}, EasyMock's \textit{java.lang.Object createMock(java.lang.Class)}, and PowerMock's \textit{java.lang.Object mock(java.lang.Class)}:
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
X x = mock(X);
\end{lstlisting}

Third, it includes values assigned from return values of read methods from mock-containing collections or arrays:
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
// array read;
// r1 is in the in-set as an array mock
X x = r1[0];
// collection read;
// r2 is in the in-set as a collection mock
X x = r2.get(0);
\end{lstlisting}

Fourth, if \texttt{x} is a mock and casted and assigned to \texttt{x\_cast}, then the gen set includes \texttt{x\_cast} (e.g. \texttt{r1} in Listing~\ref{lis:arrayIllustrationIR}):
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
// x is a mock in the in-set
X x_cast = (X) x;
\end{lstlisting}

Finally, the gen set includes copies of already-flagged mocks:
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
// x is a mock in the in-set
X y = x;
\end{lstlisting}
The copy-related rules also apply to mock-containing arrays and collections. We add some additional rules for generating mocks that the program reads from collections and arrays, as well as rules for marking arrays and collections as mock-containing. For instance, in the below array write, if the in set has \texttt{r2} as a mock, then the destination \texttt{r1} will be generated as a mock-containing array. Similarly, if \texttt{r3} is a known mock, then the collection \texttt{\$r4} to which it is added (the list of collection add methods is hardcoded) will be generated as a mock-containing collection.
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
// r2 is in the in set as a mock
r1[0] = r2;
// r3 is in the in set as a mock
$r4.<java.util.ArrayList: boolean add(java.lang.Object)>(r3);
\end{lstlisting}

% nah, we say that above now.
%% In a similar fashion, the gen set will include values that traverse the program's control-flow graph via assignments, from a value that already has mock-containing array or mock-containing collection bit set to true.

%% In this example, $\$r1$ is the immediate receiver from Mockito's mock creation site, whereas $r2$ is the casted expression that gets carried along in the subsequent program. Thus, our tool would include the immediate receivers, and the casted expressions of mock objects into the generation set, in two steps. 

\subsection{Toy Example Revisit - Soot Implementation}
\label{subsec:toy-example-soot}

Let us now revisit the toy example first introduced in Section~\ref{sec:toy-example}. 

Figure~\ref{fig:mockExample} shows how our dataflow analysis works. At the top of the Jimple IR in Listing~\ref{lis:mockExampleIR}, we begin with an empty abstraction (no mapping for any values, equivalent to all bits false for each value) before line~\ref{line:lis3line3}. For the creation of \texttt{\$r1} on line~\ref{line:lis3line3} and~\ref{line:lis3line4}, since the call to the no-arg \texttt{<init>} constructor is not one of our hardcoded mock APIs, our analysis does not declare \texttt{\$r1} to be a mock object. In practice, our abstraction simply does not create an explicit binding for \texttt{\$r1}, instead leaving the mapping empty as it was prior to line~\ref{line:lis3line3}; but it would be equivalent to create a new \texttt{MockStatus} with all bits false and bind it to \texttt{\$r1}. Thus, we may conclude that the invocation \texttt{object1.foo()} on line 5 in Figure~\ref{fig:mockExample} is not known to be a mock invocation. Tying back to our focal methods application, we would not exclude the call to \texttt{foo()} from being a possible focal method.

\begin{figure}
	\begin{lstlisting}[basicstyle=\ttfamily,
	basicstyle=\ttfamily,language = Java, framesep=4.5mm, framexleftmargin=1.0mm, captionpos=b, escapechar=|, morekeywords={@Test}]
	//        mock: |\xmark~\,|    mockAPI: |\xmark|
	Object object1 = new Object();
	
	// mock: |\xmark|
	object1.foo();
	
	//        mock: |\cmark|     mockAPI: |\cmark|
	Object object2 = mock(Object.class);
	
	// mock: |\cmark|
	object2.foo();
	\end{lstlisting}
	%    \includegraphics[width=.25\textwidth]{Images/mockInvocationIllustration.png}
	
	\caption{Our static analysis propagates mockness from sources (e.g. \texttt{mock(Object.class}) to invocations.}
	\label{fig:mockExample}
	
\end{figure}

On the other hand, our imperative analysis sees the mock-creation source methods \\ \texttt{<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>} on line~\ref{line:lis41line7} and~\ref{line:lis41line8} in the Jimple IR. It thus adds a mapping from local variable \texttt{r2} to a new \texttt{MockStatus} with the mock bit set to true. When the analysis reaches line~\ref{line:lis41line10}, because \texttt{r2} has a mapping in the abstraction with the mock bit being set, \textsc{MockDetector} will deduce that the call on line~\ref{line:lis41line10} is a mock invocation. This implies that the call to method \textit{foo()} on line 11 in Figure~\ref{fig:mockExample} cannot be a focal method.


\begin{lstlisting}[basicstyle=\ttfamily, caption={Jimple Intermediate Representation for the code in Figure~\ref{fig:mockExample}.},
basicstyle=\ttfamily, captionpos=b, label=lis:mockExampleIR, escapechar=|, morekeywords={@Test, specialinvoke, virtualinvoke, staticinvoke}]
	java.lang.Object $r1, r2;
	
	$r1 = new java.lang.Object; |\label{line:lis41line3}|
	specialinvoke $r1.<java.lang.Object: void <init>()>(); |\label{line:lis41line4}|
	virtualinvoke $r1.<java.lang.Object: void foo()>(); |\label{line:lis41line5}|
	
	r2 = staticinvoke <org.mockito.Mockito: |\label{line:lis41line7}|
					java.lang.Object mock(java.lang.Class)> |\label{line:lis41line8}|
					(class "Ljava/lang/Object;");
	virtualinvoke r2.<java.lang.Object: void foo()>(); |\label{line:lis41line10}|
\end{lstlisting}

\subsection{Arrays and Containers}

To be explicit about our treatment of arrays and containers: at a read from an array into a local variable where the source array is mock-containing, we declare that the local destination is a mock. At a write of a local variable into an array where the local variable is mock-containing, we declare that the array is mock-containing.

%%  Several test suites use arrays or collection objects to hold mock objects. In this scenario, our tool would consider that mockness propagates out to the container. For instance, say the flow function encounters an array write \begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
%%     r1[0] = r2
%% \end{lstlisting} 
%% Then, the tool will look for \texttt{r2} in the abstraction. Once the abstraction pinpoints \texttt{r2} (with mock bit on), it will include \texttt{r1} with mock-containing array bit set to true. (THIS PART STILL FEELS REPETITIVE.)


%% Taking an array as an example, our tool would first look for an array reference in the executing statement, meaning there is a read or a write from an array. If the effect is a STORE to the array, \textsc{MockDetector} would look for variables stored into the array, and check whether any of the variables have been found to be mocks. If so, it would label the array as an array mock, and set the relevant bit in the abstraction to true. Reversely, if is a LOAD effect from the array, \textsc{MockDetector} would check if the array itself has mock-containing array bit on in the abstraction. If so, it will mark the value assigned from the array LOAD with mock bit on, and store it in the abstraction.

%% *** we say more about collections in the related work, we should probably move that to here.

We treat collections analogously. However, while there is one API for arrays---the Java bytecode array load and array store instructions---Java's Collections APIs include, by our count, 60 relevant methods, which we discuss further in Section~\ref{sec:common}. For our purposes here, we use our classification of collection methods to identify collection reads and writes and handle them as we do array reads and writes, except that we say that it is a mock-containing collection, not a mock-containing array.

% The main difference is Java's \texttt{Collection} interface has multiple implementations, which expose different APIs for objects. \textsc{MockDetector} resolves this problem with a manually-constructed pool of read and write method APIs associated with each sub-type of the interface \texttt{java.util.Collection}. It subsequently checks (using the hierarchy) whether collection classes appear in statements containing invoke expression. This is achieved by first determining the declaring class of the invoked method. If the declaring class is of an interface, \textsc{MockDetector} would check whether \texttt{java.util.Collection} is a super-interface for the declaring class. Otherwise, if the declaring class is of a class type, \textsc{MockDetector} would check whether \texttt{java.util.Collection} is a super-interface for any of declaring class's implemented interfaces. If a collection sub-type container is presented, \textsc{MockDetector} would then check if a STORE effect is applied to the container, indicating some object is to be stored in the container. Once the object is determined to be a mock, the collection container variable would immediately be labelled as a collection mock, setting the relevant bit in the abstraction to true. Reversely, if a LOAD effect is applied to the container labelled as a collection mock, the object retrieved from the container will be labelled a mock, and setting the mock bit in the abstraction to true.

\subsubsection{Mock-containing Array Toy Example}

Figure~\ref{fig:arrayMockIllustration} illustrates the process of identifying a mock-containing array, and Listing~\ref{lis:arrayIllustrationIR} displays the Jimple IR of the code in Figure~\ref{fig:arrayMockIllustration}. Our analysis reaches the mock API call on line~\ref{line:lis4line4}--\ref{line:lis4line6}, where it records that \texttt{\$r2} is a mock object---it creates a MockStatus abstraction object with mock bit set to 1 and associates that object with \texttt{\$r2}. The tool then handles the cast expression assigning to \texttt{r1} on line~\ref{line:lis4line7}, giving it the same MockStatus as \texttt{\$r2}. When the analysis reaches line~\ref{line:lis4line9}, it finds an array reference on the left hand side, along with \texttt{r1} stored in the array on the right-hand side of the assignment statement. At that point, it has a MockStatus associated with \texttt{r1}, with the mock bit turned on. It can now deduce that \texttt{\$r3} on the left-hand side is an array container which may hold a mock object. Therefore, \textsc{MockDetector}'s imperative static analysis associates \texttt{\$r3} with a MockStatus with mock-containing array bit (``arrayMock'') set to 1.

\begin{figure}
	\begin{lstlisting}[
	basicstyle=\ttfamily,language = Java, framesep=4.5mm, framexleftmargin=1.0mm, captionpos=b, escapechar=|, morekeywords={@Test}]
	//        mock: |\cmark|     mockAPI: |\cmark|
	Object object1 = createMock(Object.class);
	
	// arrayMock: |\cmark| |$\Leftarrow$| array-write    |~~|  mock: |\cmark|
	objects  |~~|           = new Object[]  |~|  { object1 };
	\end{lstlisting}
	
	\caption{Our static analysis also finds array mocks.}
	\label{fig:arrayMockIllustration}
	
\end{figure}


\begin{lstlisting}[basicstyle=\ttfamily, caption={Jimple Intermediate Representation for the array in Figure~\ref{fig:arrayMockIllustration}.},
basicstyle=\ttfamily, framesep=4.5mm, framexleftmargin=1.0mm, captionpos=b, label=lis:arrayIllustrationIR, escapechar=|, morekeywords={@Test, specialinvoke, virtualinvoke, staticinvoke, newarray}]
	java.lang.Object r1, $r2;
	java.lang.Object[] $r3;
	
	$r2 = staticinvoke <org.easymock.EasyMock: |\label{line:lis4line4}|
	java.lang.Object createMock(java.lang.Class)>
	(class "java.lang.Object;"); |\label{line:lis4line6}|
	r1 = (java.lang.Object) $r2; |\label{line:lis4line7}|
	$r3 = newarray (java.lang.Object)[1]; |\label{line:lis4line8}|
	$r3[0] = r1;  |\label{line:lis4line9}|
\end{lstlisting}

\subsection{Pre-Analyses for Field Mocks Defined in Constructors and Before Methods}
\label{subsec:pre-analysis}

A number of our benchmarks define fields as referencing mock objects via EasyMock or Mockito \texttt{@Mock} annotations, or initialize these fields in the \texttt{<init>} constructor or \texttt{@Before} methods (\textit{setUp()} in JUnit 3), which test runners will execute before any test methods from those classes. These mock field or mock-containing container fields are then used in tests. In the Soot implementation, we use two pre-analyses before running the main analysis, under the assumption that fields are rarely mutated in the test cases (and that it is incorrect to do so). We have validated our assumption on benchmarks. An empirical analysis of our benchmarks shows that fewer than 0.3\% of all fields (29/9352) are mutated in tests.
%Table~\ref{tab:mutations} shows a preliminary analysis of field mutation frequency inside test cases---fewer than 0.3\% of fields are mutated in test cases.

The first pre-analysis handles annotated field mocks and field mocks defined in the constructors (\texttt{<init>} methods), while the second pre-analysis handles \texttt{@Before} and \texttt{setUp()} methods. 

\textsc{MockDetector} retrieves all fields in all test classes, and marks fields annotated {\tt @org.mockito.Mock} or {\tt @org.easymock.Mock} as mocks.
% obvious enough that we don't need to belabour this point
% Listing~\ref{lis:annotatedMock} illustrates a Mockito annotated field mock example taken from \texttt{DefaultToolchainManagerTest.java} class in maven-core.

Listing~\ref{lis:fieldMock} depicts an example where instance fields are initialized using field initializers. Java copies such initializers into all class constructors (\texttt{<init>}). To detect such mock-containing fields, we thus simply apply the forward dataflow analysis on all constructors in the test classes prior to running the main analysis, using the same logic that we use to detect mock objects or mock-containing containers in the main analysis. The second pre-analysis handles field mocks defined in \texttt{@Before} methods just like the first pre-analysis handled constructors.

%% Listing~\ref{lis:fieldMock2} illustrates an example where fields are defined as mocks via mock-creation source methods inside the @Before method. Similarly, the field mocks initialized inside the @Before methods are determined by applying the forward dataflow analysis strictly on all @Before methods before the main analysis, where the values  


%% \begin{lstlisting}[basicstyle=\ttfamily, caption={Example for Annotated field mocks from \texttt{DefaultToolchainManagerTest.java} in maven-core.},
%% basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm,
%% framexleftmargin=1mm, captionpos=b, label=lis:annotatedMock]
%% public class DefaultToolchainManagerTest
%% {
%%     @Mock
%%     private Logger logger;
%%     @Mock
%%     private ToolchainFactory toolchainFactory_basicType;
%%     @Mock
%%     private ToolchainFactory toolchainFactory_rareType;

%%     @Before
%%     public void onSetup() throws Exception
%%     {    
%%         // ...
%%         MockitoAnnotations.initMocks( this );
%%         // ...
%%     }
%% }
%% \end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, caption={Example for field mocks defined by field initializations from \texttt{TypeRuleTest.java} in jsonschema2pojo.},
basicstyle=\ttfamily,language = Java, framesep=4.5mm,
framexleftmargin=1mm, captionpos=b, label=lis:fieldMock]
	private GenerationConfig config = mock(GenerationConfig.class);
	private RuleFactory ruleFactory = mock(RuleFactory.class);
\end{lstlisting}

\subsection{Interprocedural Support} 

The Heros framework implements IFDS/IDE for program analysis frameworks including Soot. With some effort, it would be possible to rewrite our mock analysis with Heros; however, this would be a more involved process than in the declarative case, where we simply added two rules. In particular, Heros uses a different API in its implementation than Soot. Conceptually, though, it should be no harder to implement an interprocedural Heros analysis than an intraprocedural Soot dataflow analysis.

% not necessary here. you can add it to your thesis.
%% \begin{lstlisting}[basicstyle=\ttfamily, caption={Example for field mocks defined in a \texttt{@Before} method.},
%% basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm,
%% framexleftmargin=1mm, captionpos=b, label=lis:fieldMock2]
%% public class PayRollMockTest {
%%     private EmployeeDB employeeDB;
%%     private BankService bankService;

%%     @Before
%%     public void init() {
%%         // ...
%%         employeeDB = mock(EmployeeDB.class);
%%         bankService = mock(BankService.class);
%%         // ...
%%     }
%% }
%% \end{lstlisting}

\section{Declarative Doop Implementation}
\label{sec:dec-doop}

We next describe the declarative Doop-based technique that \textsc{MockDetector} uses. We implemented this technique by writing Datalog rules. Similarly to the dataflow analysis, the declarative approach propagates mockness from known mock sources, through the statements in the intermediate representation, to potential mock invocation sites.

% Mock Libraries discussed in Common Infrastructure section, perhaps refer to the paragraph in Common Infrastructure section?
The core of the implementation starts by declaring facts for 9 mock source methods manually gleaned from the mock libraries' documentation, as specified through method signatures (e.g. 
\texttt{<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>}.)
It then declares that a variable {\tt v} satisfies \verb+isMockVar(v)+ if it is assigned from the return value of a mock source, or otherwise traverses the program's interprocedural control-flow graph, through assignments, which may possibly flow through fields, collections, or arrays. Finally, an invocation site is a mock invocation if the receiver object {\tt v} satisfies \verb+isMockVar(v)+.

\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none,label={lst:core}]
// v = mock()
isMockVar(v) :-
AssignReturnValue(mi, v),
callsMockSource(mi).
// v = (type) from
isMockVar(v) :-
isMockVar(from),
AssignCast(_ /* type */, from, v, _ /* inmethod */).
// v = v1
isMockVar(v) :-
isMockVar(v1),
AssignLocal(v1, v, _).
\end{lstlisting}

The predicates \texttt{AssignReturnValue}, \texttt{AssignCast}, and \texttt{AssignLocal} are provided by Doop, and resemble Java bytecode instructions. Unlike Java bytecode, however, their arguments are explicit. For instance, \texttt{AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)} denotes an assignment statement copying from \texttt{?from} to \texttt{?to} in method \texttt{?inmethod}. (It is Datalog convention to prefix parameters with \texttt{?}s).

We designed the analysis in a modular fashion, such that the interprocedural, collections, arrays, and fields support can all be disabled through the use of \verb+#ifdef+s, which can be specified on the Doop command-line.

\subsection{Toy Example Revisit - Doop Implementation}
\label{subsec:toy-example-doop}

Again referring to Jimple Listing~\ref{lis:mockExampleIR}, this time we ask whether the invocation on Jimple line~\ref{line:lis41line10} satisfies predicate \texttt{isMockInvocation} (facts Listing~\ref{lis:facts}, line~\ref{line:facts-imi}), which we define to hold the analysis result---namely, all mock invocation sites in the program. It does, because of facts lines~\ref{line:facts-vmi}--\ref{line:facts-imv}: Jimple line~\ref{line:lis41line10} contains a virtual method invocation, and the receiver object \texttt{r2} for the invocation on that line satisfies our predicate \texttt{isMockVar}, which holds all mock-containing variables in the program (Section~\ref{sec:dec-doop} provides more details). Predicate \texttt{isMockVar} holds because of lines~\ref{line:facts-arv}--\ref{line:facts-cms}: \texttt{r2} satisfies \texttt{isMockVar} because Jimple line~\ref{line:lis41line7} assigns \texttt{r2} the return value from mock source method \texttt{createMock} (facts line~\ref{line:facts-arv}), and the call to \texttt{createMock} satisfies predicate \texttt{callsMockSource} (facts line~\ref{line:facts-cms}), which requires that the call destination \texttt{createMock} be enumerated as a constant in our 1-ary relation \texttt{MockSourceMethod} (facts line~\ref{line:facts-msm}), and that there be a call graph edge between the method invocation at line~\ref{line:lis41line7} and the mock source method (facts line~\ref{line:facts-cge}).


\begin{lstlisting}[basicstyle=\ttfamily, caption={Facts about invocation \texttt{r2.foo()} in method \texttt{test}.},
basicstyle=\ttfamily, framesep=4.5mm, framexleftmargin=1.0mm, captionpos=b, label=lis:facts, escapechar=!, morekeywords={@Test}]
	isMockInvocation(<Object: void foo()>/test/0, 
	<Object: void foo()>, test, _. r2). !\label{line:facts-imi}!
	|VirtualMethodInvocation(<Object: void foo()>/test/0, !\label{line:facts-vmi}!
	|                        <Object: void foo()>, test).
	|VirtualMethodInvocation_Base(<Object: void foo()>/test/0, 
	|                                  r2).
	|isMockVar(r2). !\label{line:facts-imv}!
	|-AssignReturnValue(<Mockito: Object mock(Class)>/test/0, !\label{line:facts-arv}!
	|                        r2). 
	|-callsMockSource(<Mockito: Object mock(Class)>/test/0). !\label{line:facts-cms}!
	|MockSourceMethod(<Mockito: Object mock(Class)>). !\label{line:facts-msm}!
	|CallGraphEdge(_, <Mockito: Object mock(Class)>/test/0, _, !\label{line:facts-cge}!
	|              <Mockito: Object mock(Class)>). 
\end{lstlisting}


\subsection{Interprocedural Support} 

From our perspective, including (context-insensitive) interprocedural support is almost trivial; we only need to add two rules
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
// v = callee(), where callee's return 
// var is mock
isInterprocMockVar(v) :-
AssignReturnValue(mi, v),
mainAnalysis.CallGraphEdge(_, mi, _, callee),
ReturnVar(v_callee, callee),
isMockVar(v_callee).

// callee(v) results in formal param 
// of callee being mock
isInterprocMockVar(v_callee) :-
isMockVar(v),
ActualParam(n, mi, v),
FormalParam(n, callee, v_callee),
mainAnalysis.CallGraphEdge(_, mi, _, callee),
Method_DeclaringType(callee, callee_class),
ApplicationClass(callee_class).
\end{lstlisting}
using Doop-provided call graph edges (relation \texttt{mainAnalysis.CallGraphEdge}) between the method invocation {\tt mi} and its callee {\tt callee}. The first rule propagates information from callees back to their callers, while the second rule propagates information from callers to callees through parameters. Note that we restrict our analysis to so-called ``application classes'', excluding in particular the Java standard library. We chose to run our conext-insensitive analysis on top of Doop's context-insensitive call graph, but have also reported results with Doop's \texttt{basic-only} analysis, which implements Class Hierarchy Analysis. Mirroring Doop, it would also be possible to add context sensitivity to our analysis, but our results suggest that this would not help much; we'll return to that point in Chapter~\ref{chap:evaluation}.

\subsection{Arrays and Containers} 

Consistent with our analysis being a may-analysis, we define a predicate \\ {\tt isArrayLocalThatContainsMocks} to record local variables pointing to arrays that may contain mock objects. This predicate is true whenever the program under analysis stores a mock variable into an array; we also transfer array-mockness through assignments and casts. When a local variable \texttt{v} is read from a mock-containing array \texttt{c}, then \texttt{v} is marked as a mock variable, as seen in the first rule below. An store of a mock variable \texttt{mv} into an array \texttt{c} causes that array to be marked as \texttt{isArrayLocalThatContainsMocks}. Note that these predicates are mutually recursive. A similar predicate is also applied to containers. We also handle {\tt Collection.toArray} by propagating mockness from the collection to the array.

\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
// v = c[idx]
isMockVar(v) :-
isArrayLocalThatContainsMocks(c),
LoadArrayIndex(c, v, _ /* idx */).

// c[idx] = mv
isArrayLocalThatContainsMocks(c) :-
StoreArrayIndex(mv, c, _ /* idx */),
isMockVar(mv).
\end{lstlisting}

\subsection{Fields} 

Apart from the obvious rule stating that a field which is assigned from a mock satisfies {\tt fieldContainsMock}, we also label fields that have the {\tt org.mockito.Mock} annotation as mock-containing. We declare that a given field \emph{signature} may contain a mock, i.e. the field with a given signature belonging to all objects of a given type. We also support containers stored in fields.

\subsection{Arrays and Fields} 

We also support not just array locals but also array fields. That is, when an array-typed field is assigned from a mock-containing array local, then it is also a mock. And when an array-typed local variable is assigned from a mock-containing array field, then that array local is a mock-containing array.

\section{Common Infrastructure}
\label{sec:common}
We have parameterized our technique with respect to mocking libraries and have instantiated it with respect to the popular Java libraries Mockito, EasyMock, and PowerMock. We also support different versions of JUnit\footnote{\url{https://junit.org}}: 3, and 4+, and we support the Java Collections API. We discuss this parameterization in this subsection.

Both JUnit and mocking libraries rely heavily on reflection to functions, and would normally pose problems for static analyses. In particular, the set of reachable test methods is enumerated at runtime, and the mock libraries create mock objects reflectively. Fortunately, their use of reflection is limited and stylized, and we have designed our analyses to soundly handle these libraries.

\subsection{JUnit and Driver Generation}

JUnit tests are simply methods that developers write in test classes, appropriately annotated (in JUnit 3 by method name starting with ``test'', in 4+ by a \texttt{@Test} annotation). A JUnit test runner uses reflection to find tests. Out of the box, static analysis engines do not see tests as reachable code.

% what about hierarchical drivers?

Thus, to enable static analysis over a benchmark's test suite, our tool uses Soot to generate a driver class for each Java sub-package of the suite (e.g. \\ \texttt{org.apache.ibatis.executor.statement}). In each of these sub-package driver classes, our tool creates a \textit{runall()} method, which invokes all methods within the sub-package that JUnit (either 3 or 4) considers to be non-constructor test cases, all surrounded by calls to class-level init/setup and teardown methods. Test methods from concrete test classes are particularly easy to call from a driver, as they are specified to have no parameters and are not supposed to rely on any particular ordering. 
Our tool then creates a RootDriver class at the root package level, which invokes the \textit{runall()} method in each sub-package driver class, along with the \texttt{@Test}/\texttt{@Before}/\texttt{@After} methods found in classes located at the root. The drivers that we generate also contain code to catch all checked exceptions declared to be thrown by the unit tests. Both our Soot and Doop implementations use the generated driver classes.

All static frameworks must somehow approximate the set of entry points as appropriate for their targets. Additionally, the Wala framework~\cite{wala19:_t} creates synthetic entry points, but it does this to perform pointer analysis on a program's main code rather than to enumerate the program's test cases.

\subsection{Intraprocedural Analysis} 

The Soot analysis is intraprocedural and the Doop analysis has an intraprocedural version. In both of these cases, we make the unsound (but reasonable for our anticipated use case) assumption that mockness can be dropped between callers and callees: at method entry points, no parameters are assumed to be mocks, and at method returns, the returned object is never a mock. Doop's interprocedural version drops this assumption, and instead context-insensitively propagates information from callers to callees and back; we discuss the results of doing so in Chapter~\ref{chap:evaluation}.

Call graphs are useful to our intraprocedural analysis in two ways: first, because they help identify calls to mock source methods (that we identify explicitly); and second, because they come with entry points (which we effectively supply to the call graph using our generated driver, as explained above). We assume that developers do not call inherited versions of mock creation sites (for example, it could be a wrapper of the mock source method). However, if a call graph of any inherited versions of mock create sites is available in Doop, our Doop implementation will use it. 

\subsection{Mock Libraries}

Our supported mock libraries take different approaches to instantiating mocks. All of the libraries have methods that generate mock objects; for instance, EasyMock contains the \texttt{createMock()} method. We consider return values from these methods to be mock objects. Additionally, Mockito contains a fluent \texttt{verify()} method which returns a mock object. Finally, Mockito and EasyMock also allow developers to mark fields as \texttt{@Mock}; we treat reads from such fields as mock objects. Both implementations start the analysis with these hard coded facts on mock source methods, as described in the mock libraries' documentation.

\subsection{Containers}

As stated above, we hardcode all relevant methods from the Java Collections API. There are 60 such methods in total, which together account for about 1/6th of the total lines in our Doop analysis. In addition to straightforward get and put methods, we also support iterators, collection copies via constructors, and add-all methods. An iterator can be treated as a copy of the container, with the request of an object from the iterator being tantamount to a container get. An add-all method copies the mock-containing collection bit.
